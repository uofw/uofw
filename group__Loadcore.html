<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>uOFW: Loadcore Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uOFW
   </div>
   <div id="projectbrief">Reverse engineered PSP kernel 6.60.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Loadcore Module</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDirectCall.html">DirectCall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSyscall.html">Syscall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionSceStub.html">SceStub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceVariableStub.html">SceVariableStub</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceBootCallback.html">SceBootCallback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceStubLibrary.html">SceStubLibrary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceResidentLibrary.html">SceResidentLibrary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCoreProtectInfo.html">SceLoadCoreProtectInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCoreBootModuleInfo.html">SceLoadCoreBootModuleInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCoreBootInfo.html">SceLoadCoreBootInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceModule.html">SceModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceSyscallTable.html">SceSyscallTable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSceLoadCore.html">SceLoadCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gabce5652c4e61f4d009c6c8a3362f30c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabce5652c4e61f4d009c6c8a3362f30c1">LIBRARY_VERSION_MINOR</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:gabce5652c4e61f4d009c6c8a3362f30c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab01a311c151ae89e396968b30403a801"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gab01a311c151ae89e396968b30403a801">LIBRARY_VERSION_MAJOR</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:gab01a311c151ae89e396968b30403a801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd8cb264d52ac2da5a2896617e3c64f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaedd8cb264d52ac2da5a2896617e3c64f">LIBRARY_VERSION_NUMBER_CATEGORY_SIZE</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="separator:gaedd8cb264d52ac2da5a2896617e3c64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc3993d7f85386f95fa6fa43be28071"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga2bc3993d7f85386f95fa6fa43be28071">LIBRARY_ENTRY_TABLE_OLD_LEN</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="separator:ga2bc3993d7f85386f95fa6fa43be28071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad50d562baa3b27ce2edba3d0786c68f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaad50d562baa3b27ce2edba3d0786c68f">LIBRARY_ENTRY_TABLE_NEW_LEN</a>&#160;&#160;&#160;(5)</td></tr>
<tr class="separator:gaad50d562baa3b27ce2edba3d0786c68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4228ecc6e2a07beaf36dc11388010ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaf4228ecc6e2a07beaf36dc11388010ba">STUB_LIBRARY_ENTRY_TABLE_OLD_LEN</a>&#160;&#160;&#160;(6)</td></tr>
<tr class="separator:gaf4228ecc6e2a07beaf36dc11388010ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eecbbcaa957b79a633619c3cd235230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga9eecbbcaa957b79a633619c3cd235230">STUB_LIBRARY_ENTRY_TABLE_NEW_LEN</a>&#160;&#160;&#160;(7)</td></tr>
<tr class="separator:ga9eecbbcaa957b79a633619c3cd235230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2659f67c57d64bd8dccf6b9ef044350"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gac2659f67c57d64bd8dccf6b9ef044350">LOADCORE_LIB_HASH_TABLE_SIZE</a>&#160;&#160;&#160;(128)</td></tr>
<tr class="separator:gac2659f67c57d64bd8dccf6b9ef044350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dc2ea4c871facd3ba43095b78d67541"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga4dc2ea4c871facd3ba43095b78d67541">SCE_BOOT_CALLBACK_FUNCTION_QUEUED</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga4dc2ea4c871facd3ba43095b78d67541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6a6e66d2215ad31f49a6ae43f0c7880"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaa6a6e66d2215ad31f49a6ae43f0c7880">SCE_PROTECT_INFO_STATE_IS_ALLOCATED</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:gaa6a6e66d2215ad31f49a6ae43f0c7880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358934f1d906e6500e9c25437ad051fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga358934f1d906e6500e9c25437ad051fa">SCE_PROTECT_INFO_TYPE_FILE_NAME</a>&#160;&#160;&#160;(0x2)</td></tr>
<tr class="separator:ga358934f1d906e6500e9c25437ad051fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513eeed6c82ce877f9210b35351bfbf5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga513eeed6c82ce877f9210b35351bfbf5">SCE_PROTECT_INFO_TYPE_VSH_PARAM</a>&#160;&#160;&#160;(0x4)</td></tr>
<tr class="separator:ga513eeed6c82ce877f9210b35351bfbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a1d52968516fd2a5fa2c6057a8b8440"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga3a1d52968516fd2a5fa2c6057a8b8440">SCE_PROTECT_INFO_TYPE_DISC_IMAGE</a>&#160;&#160;&#160;(0x40)</td></tr>
<tr class="separator:ga3a1d52968516fd2a5fa2c6057a8b8440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e818579b4eb5e3dab698579cf761da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga98e818579b4eb5e3dab698579cf761da">SCE_PROTECT_INFO_TYPE_NPDRM_DATA</a>&#160;&#160;&#160;(0x80)</td></tr>
<tr class="separator:ga98e818579b4eb5e3dab698579cf761da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cb3f8ab1b5f1ca92d3b9c3b3c3a7f2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga1cb3f8ab1b5f1ca92d3b9c3b3c3a7f2c">SCE_PROTECT_INFO_TYPE_USER_PARAM</a>&#160;&#160;&#160;(0x100)</td></tr>
<tr class="separator:ga1cb3f8ab1b5f1ca92d3b9c3b3c3a7f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga064c6f899777c70b9c3c0006d01ff847"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga064c6f899777c70b9c3c0006d01ff847">SCE_PROTECT_INFO_TYPE_PARAM_SFO</a>&#160;&#160;&#160;(0x400)</td></tr>
<tr class="separator:ga064c6f899777c70b9c3c0006d01ff847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841d1f23ad9881cd37010137d4d9152a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga841d1f23ad9881cd37010137d4d9152a">GET_PROTECT_INFO_STATE</a>(attr)&#160;&#160;&#160;((u32)(attr) &gt;&gt; 16)</td></tr>
<tr class="separator:ga841d1f23ad9881cd37010137d4d9152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4790cee80f516a6b0c8b307691f9df0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga4790cee80f516a6b0c8b307691f9df0c">SET_PROTECT_INFO_STATE</a>(state,  src)&#160;&#160;&#160;(((state) &lt;&lt; 16) | (src))</td></tr>
<tr class="separator:ga4790cee80f516a6b0c8b307691f9df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d2855309cc2ec094b642bea92ffc0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gab3d2855309cc2ec094b642bea92ffc0d">REMOVE_PROTECT_INFO_STATE</a>(state,  src)&#160;&#160;&#160;((~((state) &lt;&lt; 16)) &amp; (src))</td></tr>
<tr class="separator:gab3d2855309cc2ec094b642bea92ffc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f48480d7acf0e5cae8bce256ccf7c4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga1f48480d7acf0e5cae8bce256ccf7c4a">GET_PROTECT_INFO_TYPE</a>(attr)&#160;&#160;&#160;((attr) &amp; 0xFFFF)</td></tr>
<tr class="separator:ga1f48480d7acf0e5cae8bce256ccf7c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b8302cae9a68bcad9e065de8d81f5cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga3b8302cae9a68bcad9e065de8d81f5cc">SET_PROTECT_INFO_TYPE</a>(type,  src)&#160;&#160;&#160;(((type) &amp; 0xFFFF) | (src))</td></tr>
<tr class="separator:ga3b8302cae9a68bcad9e065de8d81f5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7d752ce6bb887f69ae32d81943d77bf7"><td class="memItemLeft" align="right" valign="top">typedef s32(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga7d752ce6bb887f69ae32d81943d77bf7">SceKernelBootCallbackFunction</a>) (void *data, s32 arg, void *opt)</td></tr>
<tr class="separator:ga7d752ce6bb887f69ae32d81943d77bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc93f0892a9ce1a492817326c5c5c8af"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSceStubLibrary.html">SceStubLibrary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabc93f0892a9ce1a492817326c5c5c8af">SceStubLibrary</a></td></tr>
<tr class="separator:gabc93f0892a9ce1a492817326c5c5c8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0200fd1d0b6bcf4be034c4d2ee4c7c6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSceResidentLibrary.html">SceResidentLibrary</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaf0200fd1d0b6bcf4be034c4d2ee4c7c6">SceResidentLibrary</a></td></tr>
<tr class="separator:gaf0200fd1d0b6bcf4be034c4d2ee4c7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cad866437598c858937aaf67e75354b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSceModule.html">SceModule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga0cad866437598c858937aaf67e75354b">SceModule</a></td></tr>
<tr class="separator:ga0cad866437598c858937aaf67e75354b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga939bb8b59b665de820d8d98f92882f23"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSceSyscallTable.html">SceSyscallTable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga939bb8b59b665de820d8d98f92882f23">SceSyscallTable</a></td></tr>
<tr class="separator:ga939bb8b59b665de820d8d98f92882f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5e1860bc052008fbebde6907abea5919"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga5e1860bc052008fbebde6907abea5919">sceKernelRegisterLibrary</a> (<a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *libEntryTable)</td></tr>
<tr class="separator:ga5e1860bc052008fbebde6907abea5919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga639e2665a0bfc1276b09f0ae597edabe"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga639e2665a0bfc1276b09f0ae597edabe">sceKernelCanReleaseLibrary</a> (<a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *libEntryTable)</td></tr>
<tr class="separator:ga639e2665a0bfc1276b09f0ae597edabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f03e8233ed3334f49c9253bb94cbb7f"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga8f03e8233ed3334f49c9253bb94cbb7f">sceKernelLinkLibraryEntries</a> (<a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *libStubTable, u32 size)</td></tr>
<tr class="separator:ga8f03e8233ed3334f49c9253bb94cbb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8025675e3f76dd3de33abe290428660c"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga8025675e3f76dd3de33abe290428660c">sceKernelUnLinkLibraryEntries</a> (<a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *libStubTable, u32 size)</td></tr>
<tr class="separator:ga8025675e3f76dd3de33abe290428660c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac154c992eeedc2eaa0088776d44a3cae"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gac154c992eeedc2eaa0088776d44a3cae">sceKernelLoadModuleBootLoadCore</a> (<a class="el" href="structSceLoadCoreBootModuleInfo.html">SceLoadCoreBootModuleInfo</a> *bootModInfo, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execInfo, SceUID *modMemId)</td></tr>
<tr class="separator:gac154c992eeedc2eaa0088776d44a3cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06690dfe9537a4eb1ab8942d4a5e0a1d"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga06690dfe9537a4eb1ab8942d4a5e0a1d">sceKernelLoadCoreLock</a> (void)</td></tr>
<tr class="separator:ga06690dfe9537a4eb1ab8942d4a5e0a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae05f15d19f46b074ae730c86c953db26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gae05f15d19f46b074ae730c86c953db26">sceKernelLoadCoreUnlock</a> (s32 intrState)</td></tr>
<tr class="separator:gae05f15d19f46b074ae730c86c953db26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43974f8ec77ca5ca2e90e025327fa55"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaf43974f8ec77ca5ca2e90e025327fa55">sceKernelRegisterLibraryForUser</a> (<a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *libEntryTable)</td></tr>
<tr class="separator:gaf43974f8ec77ca5ca2e90e025327fa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ff3206fbd6adf5e7dfb03efb67258e6"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga1ff3206fbd6adf5e7dfb03efb67258e6">sceKernelReleaseLibrary</a> (<a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *libEntryTable)</td></tr>
<tr class="separator:ga1ff3206fbd6adf5e7dfb03efb67258e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe06ce57f0c47128178c0d77fd6f3a45"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gafe06ce57f0c47128178c0d77fd6f3a45">sceKernelLinkLibraryEntriesForUser</a> (<a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *libStubTable, u32 size)</td></tr>
<tr class="separator:gafe06ce57f0c47128178c0d77fd6f3a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f0ad0656e221ae09a1da75722e8e0a2"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga8f0ad0656e221ae09a1da75722e8e0a2">sceKernelLinkLibraryEntriesWithModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod, <a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *libStubTable, u32 size)</td></tr>
<tr class="separator:ga8f0ad0656e221ae09a1da75722e8e0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6247573c87614bff810f3275d45a8a56"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga6247573c87614bff810f3275d45a8a56">sceKernelMaskLibraryEntries</a> (void)</td></tr>
<tr class="separator:ga6247573c87614bff810f3275d45a8a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b67da694093937b29662cb1fa0bd80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceLoadCore.html">SceLoadCore</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga35b67da694093937b29662cb1fa0bd80">sceKernelQueryLoadCoreCB</a> (void)</td></tr>
<tr class="separator:ga35b67da694093937b29662cb1fa0bd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4d5e3489d68d046ec7d07af2d8c6ef4"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gac4d5e3489d68d046ec7d07af2d8c6ef4">sceKernelSetBootCallbackLevel</a> (<a class="el" href="group__Loadcore.html#ga7d752ce6bb887f69ae32d81943d77bf7">SceKernelBootCallbackFunction</a> bootCBFunc, u32 flag, s32 *status)</td></tr>
<tr class="separator:gac4d5e3489d68d046ec7d07af2d8c6ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6500012c146066884c19e5b2ba4ade"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga1d6500012c146066884c19e5b2ba4ade">sceKernelLoadCoreMode</a> (void)</td></tr>
<tr class="separator:ga1d6500012c146066884c19e5b2ba4ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6a2494ffb0470b0f9599e090e50831"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga7f6a2494ffb0470b0f9599e090e50831">sceKernelCheckPspConfig</a> (u8 *file, u32 size)</td></tr>
<tr class="separator:ga7f6a2494ffb0470b0f9599e090e50831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4085a25a1930eff036090a5102aec28d"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga4085a25a1930eff036090a5102aec28d">sceKernelLoadRebootBin</a> (u8 *file, u32 size)</td></tr>
<tr class="separator:ga4085a25a1930eff036090a5102aec28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b218b4b1d73fb5e70245175b9ab3de2"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga2b218b4b1d73fb5e70245175b9ab3de2">sceKernelSegmentChecksum</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod)</td></tr>
<tr class="separator:ga2b218b4b1d73fb5e70245175b9ab3de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc44f347ed1d715e36335fefaf55c73d"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gadc44f347ed1d715e36335fefaf55c73d">sceKernelCheckExecFile</a> (u8 *buf, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execInfo)</td></tr>
<tr class="separator:gadc44f347ed1d715e36335fefaf55c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga088333b921044f7835c1d6ec9b2319af"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga088333b921044f7835c1d6ec9b2319af">sceKernelProbeExecutableObject</a> (u8 *buf, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execInfo)</td></tr>
<tr class="separator:ga088333b921044f7835c1d6ec9b2319af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7052742d9d25460b816091fdebe838"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabb7052742d9d25460b816091fdebe838">sceKernelLoadExecutableObject</a> (u8 *buf, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execInfo)</td></tr>
<tr class="separator:gabb7052742d9d25460b816091fdebe838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf7561a272d3b2cf5affab96c72145e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gadaf7561a272d3b2cf5affab96c72145e">sceKernelCreateModule</a> (void)</td></tr>
<tr class="separator:gadaf7561a272d3b2cf5affab96c72145e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf39d993dcafa17af01e1ca7c194a18"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaaaf39d993dcafa17af01e1ca7c194a18">sceKernelAssignModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod, <a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execFileInfo)</td></tr>
<tr class="separator:gaaaf39d993dcafa17af01e1ca7c194a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2413650b3190085fd16d5e0e8f501e1"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gac2413650b3190085fd16d5e0e8f501e1">sceKernelReleaseModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod)</td></tr>
<tr class="separator:gac2413650b3190085fd16d5e0e8f501e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9cffa3669a80cbdb0fec14c7cc1b3ee"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gae9cffa3669a80cbdb0fec14c7cc1b3ee">sceKernelGetModuleIdListForKernel</a> (SceUID *modIdList, u32 size, u32 *modCount, u32 userModsOnly)</td></tr>
<tr class="separator:gae9cffa3669a80cbdb0fec14c7cc1b3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30d19f5c2935c6f97b48c6e106c7a34c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga30d19f5c2935c6f97b48c6e106c7a34c">sceKernelGetModuleFromUID</a> (SceUID uid)</td></tr>
<tr class="separator:ga30d19f5c2935c6f97b48c6e106c7a34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f953301858af828e5e11084c3e2806f"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga4f953301858af828e5e11084c3e2806f">sceKernelDeleteModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod)</td></tr>
<tr class="separator:ga4f953301858af828e5e11084c3e2806f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac93803cbf0181b02ab23d7d7220040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabac93803cbf0181b02ab23d7d7220040">sceKernelCreateAssignModule</a> (<a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *execFileInfo)</td></tr>
<tr class="separator:gabac93803cbf0181b02ab23d7d7220040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f11263a69a222a15be9977fce1af50"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga78f11263a69a222a15be9977fce1af50">sceKernelRegisterModule</a> (<a class="el" href="structSceModule.html">SceModule</a> *mod)</td></tr>
<tr class="separator:ga78f11263a69a222a15be9977fce1af50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebbaa6caea1fe4f07e4f0a9436f67147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gaebbaa6caea1fe4f07e4f0a9436f67147">sceKernelFindModuleByName</a> (const char *name)</td></tr>
<tr class="separator:gaebbaa6caea1fe4f07e4f0a9436f67147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60135c1de86354096f49bc42360c8c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga60135c1de86354096f49bc42360c8c6a">sceKernelFindModuleByAddress</a> (u32 addr)</td></tr>
<tr class="separator:ga60135c1de86354096f49bc42360c8c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc7d802b414800306356518437437ea8"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gabc7d802b414800306356518437437ea8">sceKernelGetModuleGPByAddressForKernel</a> (u32 addr)</td></tr>
<tr class="separator:gabc7d802b414800306356518437437ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7965536d1d3b54d72836100caf6b57d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#gad7965536d1d3b54d72836100caf6b57d">sceKernelFindModuleByUID</a> (SceUID uid)</td></tr>
<tr class="separator:gad7965536d1d3b54d72836100caf6b57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a39d58f03c98c1e7deee348c218ed8"><td class="memItemLeft" align="right" valign="top">SceUID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Loadcore.html#ga55a39d58f03c98c1e7deee348c218ed8">sceKernelGetModuleListWithAlloc</a> (u32 *modCount)</td></tr>
<tr class="separator:ga55a39d58f03c98c1e7deee348c218ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Copyright (C) 2011, 2012, 2013 The uOFW team See the file COPYING for copying permission.<br />
Module loader and library import/export manager. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gabce5652c4e61f4d009c6c8a3362f30c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBRARY_VERSION_MINOR&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Library number category minor. </p>

</div>
</div>
<a class="anchor" id="gab01a311c151ae89e396968b30403a801"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBRARY_VERSION_MAJOR&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Library number category major. </p>

</div>
</div>
<a class="anchor" id="gaedd8cb264d52ac2da5a2896617e3c64f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBRARY_VERSION_NUMBER_CATEGORY_SIZE&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Current number category size for libraries. </p>

</div>
</div>
<a class="anchor" id="ga2bc3993d7f85386f95fa6fa43be28071"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBRARY_ENTRY_TABLE_OLD_LEN&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The length of the old resident library entry table format (without the members unk16 - uk19). </p>

</div>
</div>
<a class="anchor" id="gaad50d562baa3b27ce2edba3d0786c68f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIBRARY_ENTRY_TABLE_NEW_LEN&#160;&#160;&#160;(5)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The length of the new resident library entry table format (including the members unk16 - unk19). </p>

</div>
</div>
<a class="anchor" id="gaf4228ecc6e2a07beaf36dc11388010ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_LIBRARY_ENTRY_TABLE_OLD_LEN&#160;&#160;&#160;(6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The length of the old stub library entry table format (without the member unk24). </p>

</div>
</div>
<a class="anchor" id="ga9eecbbcaa957b79a633619c3cd235230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_LIBRARY_ENTRY_TABLE_NEW_LEN&#160;&#160;&#160;(7)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The length of the new stub library entry table format (including the member unk24). </p>

</div>
</div>
<a class="anchor" id="gac2659f67c57d64bd8dccf6b9ef044350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOADCORE_LIB_HASH_TABLE_SIZE&#160;&#160;&#160;(128)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The possible number of libraries with different hash values. </p>

</div>
</div>
<a class="anchor" id="ga4dc2ea4c871facd3ba43095b78d67541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCE_BOOT_CALLBACK_FUNCTION_QUEUED&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a boot callback function was added to the internal boot callback queue. </p>

</div>
</div>
<a class="anchor" id="gaa6a6e66d2215ad31f49a6ae43f0c7880"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCE_PROTECT_INFO_STATE_IS_ALLOCATED&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The protected information block is allocated. </p>

</div>
</div>
<a class="anchor" id="ga358934f1d906e6500e9c25437ad051fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCE_PROTECT_INFO_TYPE_FILE_NAME&#160;&#160;&#160;(0x2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of the protected information block is a file name. </p>

</div>
</div>
<a class="anchor" id="ga513eeed6c82ce877f9210b35351bfbf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCE_PROTECT_INFO_TYPE_VSH_PARAM&#160;&#160;&#160;(0x4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of the protected information block is a VSH param. </p>

</div>
</div>
<a class="anchor" id="ga3a1d52968516fd2a5fa2c6057a8b8440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCE_PROTECT_INFO_TYPE_DISC_IMAGE&#160;&#160;&#160;(0x40)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of the protected information block is a disc image. </p>

</div>
</div>
<a class="anchor" id="ga98e818579b4eb5e3dab698579cf761da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCE_PROTECT_INFO_TYPE_NPDRM_DATA&#160;&#160;&#160;(0x80)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates protected information block belongs to a NPDRM package. </p>

</div>
</div>
<a class="anchor" id="ga1cb3f8ab1b5f1ca92d3b9c3b3c3a7f2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCE_PROTECT_INFO_TYPE_USER_PARAM&#160;&#160;&#160;(0x100)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of the protected information block is a user param. </p>

</div>
</div>
<a class="anchor" id="ga064c6f899777c70b9c3c0006d01ff847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCE_PROTECT_INFO_TYPE_PARAM_SFO&#160;&#160;&#160;(0x400)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of the protected information block is a param.sfo. </p>

</div>
</div>
<a class="anchor" id="ga841d1f23ad9881cd37010137d4d9152a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_PROTECT_INFO_STATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">attr</td><td>)</td>
          <td>&#160;&#160;&#160;((u32)(attr) &gt;&gt; 16)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the state of a protected information block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4790cee80f516a6b0c8b307691f9df0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SET_PROTECT_INFO_STATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">state, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((state) &lt;&lt; 16) | (src))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a new state of a protected information block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The new state to set. </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab3d2855309cc2ec094b642bea92ffc0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define REMOVE_PROTECT_INFO_STATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">state, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((~((state) &lt;&lt; 16)) &amp; (src))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a state entry of a protected information block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state entry to remove. </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f48480d7acf0e5cae8bce256ccf7c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_PROTECT_INFO_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">attr</td><td>)</td>
          <td>&#160;&#160;&#160;((attr) &amp; 0xFFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the type of a protected information block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b8302cae9a68bcad9e065de8d81f5cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SET_PROTECT_INFO_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((type) &amp; 0xFFFF) | (src))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the type of a protected information block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The new type to set. </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="structSceLoadCoreProtectInfo.html#a486599c50b16a5990da1d65cc377d7fc">SceLoadCoreProtectInfo.attr</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga7d752ce6bb887f69ae32d81943d77bf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef s32(* SceKernelBootCallbackFunction) (void *data, s32 arg, void *opt)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boot Callback function. </p>

</div>
</div>
<a class="anchor" id="gabc93f0892a9ce1a492817326c5c5c8af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSceStubLibrary.html">SceStubLibrary</a>  <a class="el" href="structSceStubLibrary.html">SceStubLibrary</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure represents a stub library control block. This control block is used to manage a stub library entry table internal. </p>

</div>
</div>
<a class="anchor" id="gaf0200fd1d0b6bcf4be034c4d2ee4c7c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSceResidentLibrary.html">SceResidentLibrary</a>  <a class="el" href="structSceResidentLibrary.html">SceResidentLibrary</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure represents a resident library control block. This control block is used to manage a resident library entry table registered to the system. </p>

</div>
</div>
<a class="anchor" id="ga0cad866437598c858937aaf67e75354b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSceModule.html">SceModule</a>  <a class="el" href="structSceModule.html">SceModule</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="structSceModule.html">SceModule</a> structure represents a loaded module in memory. </p>

</div>
</div>
<a class="anchor" id="ga939bb8b59b665de820d8d98f92882f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSceSyscallTable.html">SceSyscallTable</a>  <a class="el" href="structSceSyscallTable.html">SceSyscallTable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure represents a system call table. Such a table takes care of the exported system calls registered to the system. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga95f11f1d387b7f449d120152ebdd78da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Loadcore.html#ga95f11f1d387b7f449d120152ebdd78da">SceExecFileAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executable File Attributes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga95f11f1d387b7f449d120152ebdd78daa2635299e99ea51f197742dc25d9e7579"></a>SCE_EXEC_FILE_COMPRESSED&#160;</td><td class="fielddoc">
<p>The file is compressed. If SCE_EXEC_FILE_KL4E_COMPRESSED is not set, the file is GZIP compressed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga95f11f1d387b7f449d120152ebdd78daa9dc2ea24ff1f515ac7ab448389287f3d"></a>SCE_EXEC_FILE_ELF&#160;</td><td class="fielddoc">
<p>The file is a static ELF. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga95f11f1d387b7f449d120152ebdd78daab9da304786edd19dcd9ac2799ed128ec"></a>SCE_EXEC_FILE_GZIP_OVERLAP&#160;</td><td class="fielddoc">
<p>The file has GZIP overlap. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga95f11f1d387b7f449d120152ebdd78daa8273376737c53e1c33867fde57ea1642"></a>SCE_EXEC_FILE_KL4E_COMPRESSED&#160;</td><td class="fielddoc">
<p>The file is KL4E compressed. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf2f41164f95332df5f4cdfc55724142d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Loadcore.html#gaf2f41164f95332df5f4cdfc55724142d">SceExecFileModeAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Executable File Mode Attributes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf2f41164f95332df5f4cdfc55724142da2e05bd98289d259703e35d844f1b0a7f"></a>SCE_EXEC_FILE_DECRYPT&#160;</td><td class="fielddoc">
<p>The file is decrypted. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf2f41164f95332df5f4cdfc55724142da12007ebccfbbd42bb2db7defc9d76ca5"></a>SCE_EXEC_FILE_NO_HEADER_COMPRESSION&#160;</td><td class="fielddoc">
<p>The file header is not compressed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf2f41164f95332df5f4cdfc55724142da313d43bac909fc9039fd2292fc9babfc"></a>SCE_EXEC_FILE_NO_COMPRESSION&#160;</td><td class="fielddoc">
<p>The file is not compressed. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gadd729faad5a09adb92f9099655dbccef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Loadcore.html#gadd729faad5a09adb92f9099655dbccef">SceExecFileElfType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The possible ELF type of an executable. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadd729faad5a09adb92f9099655dbccefada14f19afa4a1b965e690d316189be63"></a>SCE_EXEC_FILE_TYPE_INVALID_ELF&#160;</td><td class="fielddoc">
<p>The executable file is not an ELF. Such a file cannot be loaded. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadd729faad5a09adb92f9099655dbccefaca76b40bd50defed6c3b676f0dca9413"></a>SCE_EXEC_FILE_TYPE_PRX&#160;</td><td class="fielddoc">
<p>The executable file is a PRX, a relocatable ELF. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadd729faad5a09adb92f9099655dbccefa95388c00f97c01ef0408e76ace88f924"></a>SCE_EXEC_FILE_TYPE_PRX_2&#160;</td><td class="fielddoc">
<p>The executable file is a PRX, a relocatable ELF. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadd729faad5a09adb92f9099655dbccefae9ec646eaef857a366eb11ba1c484d7e"></a>SCE_EXEC_FILE_TYPE_ELF&#160;</td><td class="fielddoc">
<p>The executable file is a static ELF. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga3a4646a2fd1ce198fa2ec6e11a6d7fc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Loadcore.html#ga3a4646a2fd1ce198fa2ec6e11a6d7fc1">SceLibAttr</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resident/Stub library attributes. Several members can be bitwise OR'ed together. Every library needs to have at least one of those attributes. Resident libraries can have the members SCE_LIB_AUTO_EXPORT, SCE_LIB_WEAK_EXPORT, (SCE_LIB_NOLINK_EXPORT), SCE_LIB_SYSCALL_EXPORT and SCE_LIB_IS_SYSLIB. Stub libraries can have SCE_LIB_NO_SPECIAL_ATTR or SCE_LIB_WEAK_IMPORT. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a6617d512bb4fcff495982ae9c6fd5b08"></a>SCE_LIB_NO_SPECIAL_ATTR&#160;</td><td class="fielddoc">
<p>The library has no special attributes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a72abd726e9fd4d7e5a96daf0bf561305"></a>SCE_LIB_AUTO_EXPORT&#160;</td><td class="fielddoc">
<p>Automatically register the library to the system. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a3390ddabf6d87ed90c95e7714a89f9f9"></a>SCE_LIB_WEAK_EXPORT&#160;</td><td class="fielddoc">
<p>Indicates resident library can be overwritten. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1ac854cee6ed7e91f11188b1e1b11a4df1"></a>SCE_LIB_NOLINK_EXPORT&#160;</td><td class="fielddoc">
<p>Indicates resident library is NOT being linked. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a58899b8e37207888395c438fc8deef45"></a>SCE_LIB_WEAK_IMPORT&#160;</td><td class="fielddoc">
<p>Load module that references this library even if this library is not registered. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a6c80618f7587629ad51babc32f0e596f"></a>SCE_LIB_SYSCALL_EXPORT&#160;</td><td class="fielddoc">
<p>Indicates the use of the SYSCALL technique for linking. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3a4646a2fd1ce198fa2ec6e11a6d7fc1a2d6c3bfc81bdc0c297a1c13dbb8bfdd1"></a>SCE_LIB_IS_SYSLIB&#160;</td><td class="fielddoc">
<p>The library is a system library (a mandatory library for all modules). </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5e1860bc052008fbebde6907abea5919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelRegisterLibrary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libEntryTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a resident library's entry table in the system. A resident module can register any number of resident libraries. Note that this function is only meant to register kernel mode resident libraries. In order to register user mode libraries, use <a class="el" href="group__Loadcore.html#gaf43974f8ec77ca5ca2e90e025327fa55">sceKernelRegisterLibraryForUser()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libEntryTable</td><td>Pointer to the resident library's entry table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga639e2665a0bfc1276b09f0ae597edabe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelCanReleaseLibrary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libEntryTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a resident library can be released. This check returns "true" when all corresponding stub libraries at the time of the check have one the following status: a) unlinked b) have the the attribute SCE_LIB_WEAK_IMPORT (they can exist without the resident library being registered).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libEntryTable</td><td>Pointer to the resident library's entry table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 indicates the library can be released. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f03e8233ed3334f49c9253bb94cbb7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelLinkLibraryEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libStubTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link kernel mode stub libraries with the corresponding registered resident libraries. Note that this function assumes that the resident libraries linked with reside in kernel memory. Linking with user mode resident libraries will result in failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libStubTable</td><td>Pointer to a stub library's entry table. If you want to link an array of entry tables, make libStubTable a pointer to the first element of that array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of entry tables to link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8025675e3f76dd3de33abe290428660c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelUnLinkLibraryEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libStubTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlink stub libraries from their corresponding registered resident libraries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libStubTable</td><td>Pointer to a stub library's entry table. If you want to unlink an array of entry tables, make libStubTable a pointer to the first element of that array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of entry tables to unlink. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gac154c992eeedc2eaa0088776d44a3cae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelLoadModuleBootLoadCore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreBootModuleInfo.html">SceLoadCoreBootModuleInfo</a> *&#160;</td>
          <td class="paramname"><em>bootModInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SceUID *&#160;</td>
          <td class="paramname"><em>modMemId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a module. This function is used to boot modules during the start of Loadcore. In order for a module to be loaded, it has to be a kernel module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bootModInfo</td><td>Pointer to module information (including the file content of the module, its size,...) used to boot the module. </td></tr>
    <tr><td class="paramname">execInfo</td><td>Pointer an allocated execInfo structure used to handle load-checks against the program module. Furthermore, it collects various information about the module, such as its elfType, its segments (.text, .data, .bss), the locations of its exported functions. </td></tr>
    <tr><td class="paramname">modMemId</td><td>The memory id of the allocated kernelPRX memory block used for the program module sections. The memory block specified by the ID holds the .text segment of the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06690dfe9537a4eb1ab8942d4a5e0a1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelLoadCoreLock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save interrupts state and disable all interrupts.</p>
<dl class="section return"><dt>Returns</dt><dd>The current state of the interrupt controller. Use <a class="el" href="group__Loadcore.html#gae05f15d19f46b074ae730c86c953db26">sceKernelLoadCoreUnlock()</a> to return to that state. </dd></dl>

</div>
</div>
<a class="anchor" id="gae05f15d19f46b074ae730c86c953db26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sceKernelLoadCoreUnlock </td>
          <td>(</td>
          <td class="paramtype">s32&#160;</td>
          <td class="paramname"><em>intrState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return interrupt state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intrState</td><td>The state acquired by <a class="el" href="group__Loadcore.html#ga06690dfe9537a4eb1ab8942d4a5e0a1d">sceKernelLoadCoreLock()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf43974f8ec77ca5ca2e90e025327fa55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelRegisterLibraryForUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libEntryTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a user mode resident library's entry table in the system. A resident module can register any number of resident libraries. In order to register kernel mode libraries, use <a class="el" href="group__Loadcore.html#ga5e1860bc052008fbebde6907abea5919">sceKernelRegisterLibrary()</a>.</p>
<p>Restrictions on user mode resident libraries: 1) The resident library has to live in user memory. 2) Functions cannot be exported via the SYSCALL technique. 3) The resident library cannot be linked with stub libraries living in kernel memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libEntryTable</td><td>Pointer to the resident library's entry table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ff3206fbd6adf5e7dfb03efb67258e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelReleaseLibrary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceResidentLibraryEntryTable.html">SceResidentLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libEntryTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a registered resident library from the system. Deletion cannot be performed if there are loaded modules using the resident library. These modules must be deleted first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libEntryTable</td><td>Pointer to the resident library's entry table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe06ce57f0c47128178c0d77fd6f3a45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelLinkLibraryEntriesForUser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libStubTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">libStubTable</td><td>Pointer to a stub library's entry table. If you want to link an array of entry tables, make libStubTable a pointer to the first element of that array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of entry tables to link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f0ad0656e221ae09a1da75722e8e0a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelLinkLibraryEntriesWithModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceStubLibraryEntryTable.html">SceStubLibraryEntryTable</a> *&#160;</td>
          <td class="paramname"><em>libStubTable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Pointer to a module. Should not be NULL. The module seems not to be used for anything useful. </td></tr>
    <tr><td class="paramname">libStubTable</td><td>Pointer to a stub library's entry table. If you want to link an array of entry tables, make libStubTable a pointer to the first element of that array. </td></tr>
    <tr><td class="paramname">size</td><td>The number of entry tables to link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6247573c87614bff810f3275d45a8a56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceKernelMaskLibraryEntries </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does nothing but a simple return.</p>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga35b67da694093937b29662cb1fa0bd80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceLoadCore.html">SceLoadCore</a>* sceKernelQueryLoadCoreCB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get Loadcore's control block. The block takes care of the registered libraries, the unlinked stub libraries living in memory and the currently loaded modules.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to Loadcore's internal control block. </dd></dl>

</div>
</div>
<a class="anchor" id="gac4d5e3489d68d046ec7d07af2d8c6ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelSetBootCallbackLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Loadcore.html#ga7d752ce6bb887f69ae32d81943d77bf7">SceKernelBootCallbackFunction</a>&#160;</td>
          <td class="paramname"><em>bootCBFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">s32 *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a boot callback. Call this function during a module boot process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bootCBFunc</td><td>The boot callback function to execute once the important system modules (up to init.prx) have been booted. </td></tr>
    <tr><td class="paramname">flag</td><td>Defines the execute order of the callbacks. Pass 0 for earliest execution, 3 for latest. 1 and 2 are between these two. </td></tr>
    <tr><td class="paramname">status</td><td>The returned status of bootCBFunc in case it was executed directly.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for directly executing the boot callback function. 1 indicates boot callback function was enqueued into other existing boot callbacks and will be called after init.prx got booted. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d6500012c146066884c19e5b2ba4ade"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 sceKernelLoadCoreMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does nothing but a simple return, probably a debug function.</p>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f6a2494ffb0470b0f9599e090e50831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelCheckPspConfig </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check and decrypt a PSP configuration file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The configuration file (i.e. pspbtcnf.bin) to decrypt. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the decrypted file on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4085a25a1930eff036090a5102aec28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelLoadRebootBin </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrypt and load a reboot file used to boot the system. Reboot.bin is only used for kernel reboots (warm reboots only).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The reboot file to use (i.e. reboot.bin). </td></tr>
    <tr><td class="paramname">size</td><td>The size of the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b218b4b1d73fb5e70245175b9ab3de2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelSegmentChecksum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a checksum of every segment of a module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to create the checksum for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The checksum. Shouldn't be 0. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc44f347ed1d715e36335fefaf55c73d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelCheckExecFile </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check an executable file. This contains scanning its ELF header and ~PSP header (if it has one) and filling the execInfo structure with basic information, like the ELF type, segment information, the size of the executable. The file is also uncompressed, if it was compressed before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the file's contents. </td></tr>
    <tr><td class="paramname">execInfo</td><td>Pointer to the executionInfo belonging to that executable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga088333b921044f7835c1d6ec9b2319af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelProbeExecutableObject </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Probe an executable file. This contains calculating the sizes for the three segments TEXT, DATA and BSS, filling the execInfo structure with information about the location and sizes of the resident/stub library entry tables. Furthermore, it is checked whether the executable has valid API type or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the file's contents. </td></tr>
    <tr><td class="paramname">execInfo</td><td>Pointer to the executionInfo belonging to that executable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gabb7052742d9d25460b816091fdebe838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelLoadExecutableObject </td>
          <td>(</td>
          <td class="paramtype">u8 *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load an executable file. This contains allocating s memory block containing the three segments TEXT, DATA and BSS (in case the executable consists of only these three sections). Furthermore, relocation of the executable file, if needed, is also taken care off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to the file's contents. </td></tr>
    <tr><td class="paramname">execInfo</td><td>Pointer to the executionInfo belonging to that executable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gadaf7561a272d3b2cf5affab96c72145e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* sceKernelCreateModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate memory for a new <a class="el" href="structSceModule.html">SceModule</a> structure and fill it with default values. This function is called during the loading process of a module.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaaf39d993dcafa17af01e1ca7c194a18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelAssignModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execFileInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a module and check if it can be loaded, is a valid module and copy the moduleInfo section of the execution file over to the <a class="el" href="structSceModule.html">SceModule</a> structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to receive the moduleInfo section data based on the provided execution file information. </td></tr>
    <tr><td class="paramname">execFileInfo</td><td>The execution file information used to copy over the moduleInfo section for the specified module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2413650b3190085fd16d5e0e8f501e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelReleaseModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlink a module from the internal loaded-modules-linked-list. The module has to be stopped before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9cffa3669a80cbdb0fec14c7cc1b3ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelGetModuleIdListForKernel </td>
          <td>(</td>
          <td class="paramtype">SceUID *&#160;</td>
          <td class="paramname"><em>modIdList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>modCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>userModsOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive a list of UIDs of loaded modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modIdList</td><td>Pointer to a SceUID array which will receive the UIDs of the loaded modules. </td></tr>
    <tr><td class="paramname">size</td><td>Size of modIdList. Specifies the number of entries that can be stored into modIdList. </td></tr>
    <tr><td class="paramname">modCount</td><td>A pointer which will receive the total number of loaded modules. </td></tr>
    <tr><td class="paramname">userModsOnly</td><td>Set to 1 to only receive UIDs from user mode modules. Set to 0 to receive UIDs from all loaded modules.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30d19f5c2935c6f97b48c6e106c7a34c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* sceKernelGetModuleFromUID </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a loaded module from its UID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>The UID (of a module) to check for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the found <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f953301858af828e5e11084c3e2806f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelDeleteModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a module from the system. The module has to be stopped and released before.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gabac93803cbf0181b02ab23d7d7220040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* sceKernelCreateAssignModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceLoadCoreExecFileInfo.html">SceLoadCoreExecFileInfo</a> *&#160;</td>
          <td class="paramname"><em>execFileInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and assign a module. It provides the same result as a <a class="el" href="group__Loadcore.html#gadaf7561a272d3b2cf5affab96c72145e">sceKernelCreateModule()</a> call followed by a <a class="el" href="group__Loadcore.html#gaaaf39d993dcafa17af01e1ca7c194a18">sceKernelAssignModule()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">execFileInfo</td><td>The execution file information used to copy over the moduleInfo section for the specified module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga78f11263a69a222a15be9977fce1af50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelRegisterModule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structSceModule.html">SceModule</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a module in the system and link it into the internal loaded-modules-linked-list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module to register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0. </dd></dl>

</div>
</div>
<a class="anchor" id="gaebbaa6caea1fe4f07e4f0a9436f67147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* sceKernelFindModuleByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a loaded module by its name. If more than one module with the same name is loaded, return the module which was loaded last.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the module to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the found <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60135c1de86354096f49bc42360c8c6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* sceKernelFindModuleByAddress </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a loaded module containing the specified address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Memory address belonging to the module, i.e. the address of a function/global variable within the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the found <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc7d802b414800306356518437437ea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 sceKernelGetModuleGPByAddressForKernel </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the global pointer value of a module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Memory address belonging to the module, i.e. the address of a function/global variable within the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The global pointer value (greater than 0) of the found module on success. </dd></dl>

</div>
</div>
<a class="anchor" id="gad7965536d1d3b54d72836100caf6b57d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSceModule.html">SceModule</a>* sceKernelFindModuleByUID </td>
          <td>(</td>
          <td class="paramtype">SceUID&#160;</td>
          <td class="paramname"><em>uid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a loaded module by its UID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uid</td><td>The UID of the module to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the found <a class="el" href="structSceModule.html">SceModule</a> structure on success, otherwise NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga55a39d58f03c98c1e7deee348c218ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SceUID sceKernelGetModuleListWithAlloc </td>
          <td>(</td>
          <td class="paramtype">u32 *&#160;</td>
          <td class="paramname"><em>modCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receive a list of UIDs of all loaded modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modCount</td><td>A pointer which will receive the total number of loaded modules.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The UID of the allocated array containing UIDs of the loaded modules on success. It should be greater than 0. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 2 2021 14:57:47 for uOFW by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
